include "../std/std.t++"

:vec3
def new() = { x = 0, y = 0, z = 0 }
def new(x, y, z) = { x = x, y = y, z = z }

def copy(self, other) = (
    printf("%s = %s\n", self.string, other.string)
    self.x = other.x
    self.y = other.y
    self.z = other.z
)

def x(self) = self.x
def y(self) = self.y
def z(self) = self.z

def neg(self) = vec3:new(-self.x, -self.y, -self.z)

def adde(self, v) = (
    self.x += v.x
    self.y += v.y
    self.z += v.z
    self
)

def mule(self, t) = (
    self.x *= t
    self.y *= t
    self.z *= t
    self
)

def dive(self, t) = vec3:mule(self, 1 / t)

def length_squared(self) = self.x * self.x + self.y * self.y + self.z * self.z
def length(self) = sqrt(vec3:length_squared(self))

def near_zero(self) = (
    def s = 0.00000001
    def is = (abs(self.x) < s) && (abs(self.y) < s) && (abs(self.z) < s)
)

def add(l, r) = vec3:new(l.x + r.x, l.y + r.y, l.z + r.z)
def sub(l, r) = vec3:new(l.x - r.x, l.y - r.y, l.z - r.z)
def mul(l, r) = vec3:new(l.x * r.x, l.y * r.y, l.z * r.z)
def muln(l, r) = vec3:new(l.x * r, l.y * r, l.z * r)
def nmul(l, r) = vec3:muln(r, l)
def div(l, r) = vec3:muln(l, 1 / r)

def dot(l, r) = l.x * r.x + l.y * r.y + l.z * r.z
def cross(l, r) = vec3:new(
    l.y * r.z - l.z * r.y,
    l.z * r.x - l.x * r.z,
    l.x * r.y - l.y * r.x
)

def unit_vector(v) = vec3:div(v, vec3:length(v))

def random() = vec3:new(random(), random(), random())
def random(min, max) = vec3:new(random(min, max), random(min, max), random(min, max))
def random_in_unit_sphere() = (
    def p = vec3:random(-1, 1)
    while [vec3:length_squared(p) >= 1]
        p = vec3:random(-1, 1)
    p
)
def random_unit_vector() = vec3:unit_vector(vec3:random_in_unit_sphere())
def random_on_hemisphere(normal) = (
    def on_unit_sphere = vec3:random_unit_vector()
    if [vec3:dot(on_unit_sphere, normal) > 0]
        on_unit_sphere
    else vec3:neg(on_unit_sphere)
)

def reflect(v, n) = vec3:sub(v, vec3:nmul(2 * vec3:dot(v, n), n))

:vec3
