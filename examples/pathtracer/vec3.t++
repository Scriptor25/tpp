include "../std/std.t++"

:vec3
def [f64] new() = {0, 0, 0}
def [f64] new(f64 x, f64 y, f64 z) = {x, y, z}

def copy([f64] self, [f64] other) = (
    self[0] = other[0]
    self[1] = other[1]
    self[2] = other[2]
)

def f64 x([f64] self) = self[0]
def f64 y([f64] self) = self[1]
def f64 z([f64] self) = self[2]

def [f64] neg([f64] self) = vec3:new(-self[0], -self[1], -self[2])

def [f64] adde([f64] self, [f64] v) = (
    self[0] += v[0]
    self[1] += v[1]
    self[2] += v[2]
    self
)

def [f64] mule([f64] self, f64 t) = (
    self[0] *= t
    self[1] *= t
    self[2] *= t
    self
)

def [f64] dive([f64] self, f64 t) = vec3:mule(self, 1 / t)

def f64 length_squared([f64] self) = self[0] * self[0] + self[1] * self[1] + self[2] * self[2]
def f64 length([f64] self) = sqrt(vec3:length_squared(self))

def i1 near_zero([f64] self) = (
    def s = 0.00000001
    def is = (abs(self[0]) < s) && (abs(self[1]) < s) && (abs(self[2]) < s)
)

def [f64] add([f64] l, [f64] r) = vec3:new(l[0] + r[0], l[1] + r[1], l[2] + r[2])
def [f64] sub([f64] l, [f64] r) = vec3:new(l[0] - r[0], l[1] - r[1], l[2] - r[2])
def [f64] mul([f64] l, [f64] r) = vec3:new(l[0] * r[0], l[1] * r[1], l[2] * r[2])
def [f64] muln([f64] l, f64 r) = vec3:new(l[0] * r, l[1] * r, l[2] * r)
def [f64] nmul(f64 l, [f64] r) = vec3:muln(r, l)
def [f64] div([f64] l, f64 r) = vec3:muln(l, 1 / r)

def f64 dot([f64] l, [f64] r) = l[0] * r[0] + l[1] * r[1] + l[2] * r[2]
def [f64] cross([f64] l, [f64] r) = vec3:new(
    l[1] * r[2] - l[2] * r[1],
    l[2] * r[0] - l[0] * r[2],
    l[0] * r[1] - l[1] * r[0]
)

def [f64] unit_vector([f64] v) = vec3:div(v, vec3:length(v))

def random() = vec3:new(random(), random(), random())
def random(min, max) = vec3:new(random(min, max), random(min, max), random(min, max))
def random_in_unit_sphere() = (
    def p = vec3:random(-1, 1)
    while [vec3:length_squared(p) >= 1]
        p = vec3:random(-1, 1)
    p
)
def random_unit_vector() = vec3:unit_vector(vec3:random_in_unit_sphere())
def random_on_hemisphere(normal) = (
    def on_unit_sphere = vec3:random_unit_vector()
    if [vec3:dot(on_unit_sphere, normal) > 0]
        on_unit_sphere
    else vec3:neg(on_unit_sphere)
)

def reflect(v, n) = vec3:sub(v, vec3:nmul(2 * vec3:dot(v, n), n))

:vec3
